createdAt: "2018-06-27T06:25:20.149Z"
updatedAt: "2018-07-08T08:58:12.506Z"
type: "SNIPPET_NOTE"
folder: "65eddf1377d9280594ea"
title: "Docker_General"
description: "Docker_General"
snippets: [
  {
    name: "General.py"
    mode: "Python"
    content: '''
      # $ docker(dockerコマンド) run(サブコマンド) hello-world(イメージの設定)
      
      
      # $ docker run docker/whalesay cowsay Hello!
        docker run Dockerのイメージ 実行コマンド
        docker run ubuntu:latest /bin/echo 'Hello world'
        Ubuntuのイメージを元にDockerコンテナを作成/実行し,作成したコンテナ内で
        " Hello world "を表示する
      
        コンテナで呼び出すコマンドはcowsay Hello!
        イメージの後ろにコンテナが立ち上がった後にコマンドを実行することができる   
        createステータスとrunningステータスを同時に行う
      
      
      
      # $ docker images
        イメージの一覧を表示するサブコマンド
        -a : すべてのイメージを表示 
        --digests : ダイジェストを表示
        --no-trunc : 結果を全て表示
        -q : DockerイメージIDのみ表示
      
      
      # $ docker tag docker/whalesay my_whalesay:TAG_NAME
        イメージにタグ付けするコマンド
        "tag" = タグ付けするサブコマンド
        "docker/whalesay"=元となるイメージ名
        "my_walesay"=新しいイメージ名
        ":TAG_NAME"=tag名を指定できる。
      
      
      # $ docker inspect [option] コンテナ識別子またはイメージ識別子
        イメージの詳細情報を確認する
        $ docker inspect my_whalesay 
        イメージの詳細情報を表示するコマンド
        "inspect"=イメージの詳細情報を表示するサブコマンド
        "my_whalesay"=対象のイメージ名 or イメージID
      
        結果
        "ID" : イメージID
        "Created" : 作成日
        "DockerVersion" :  Dockerのバージョン
        "Author" : イメージの作成者
        "Architecture" : CPUのアーキテクチャ
          
          
        $ docker inspect --format="{{ .Os}}" ubuntu
        Osの部分だけを取得する
        $ docker inspect --format="{{ .Config.Image}}" ubuntu
        Configの中のImageを取得する
      
        
      # $ docker rmi docker/whalesay
        ローカルのイメージを削除するコマンド
        "rmi"=ローカル上のイメージを削除するサブコマンド
        "docker/shalesay"=削除対象はイメージ名 or イメージID
        "-f" =で強制削除する docker rmi -f docker/whalesay
      
      
      # $ docker pull docker/whalesay
        docker hub上に存在するイメージを取得することができる　
        "pull"=イメージを取得するサブコマンド
        "docker/whalesay"=所得したイメージ
      
      
      # $ docker build -t docker-whale .
      イメージをビルドするコマンド
      "build"=イメージをビルドするサブコマンド
      "-t, docker-whale"=タグ名の指定
      "."=ビルドコンテキストの指定(イメージを作成する際にアクセスできるファイルの範囲を示す)
        イメージビルド時にビルドコンテキストのファイルやディレクトリはまとめてdockerデーモンに
        送信される。大きなファイルが含まれる場合は送信に時間がかかる。
      
      "--no-cache"=DockerFileに変更がないと実行されないことがあり、
          新しくライブラリをインス トールしてるんだけど、
          apt-getが実行されない場合があるので、--no-cacheオプションをつける
          'docker build --no-cache -t docker-whale .'
          
          
      # nginxのコンテナを立ち上げるコマンド
        $ docker run --name test-nginx -d -p 8080:80 nginx 
        $ docker run --name <コンテナ名> -d \\
        -p <ホスト側のポート番号>:<コンテナ側のポート番号> \\
        <イメージ名>
      
        "--name"=起動するコンテナに名前をつけるオプション
        "-d"=デタッチモード、コンテナの実行をバックグラウンドで行う
        "-p"=コンテナのポートをコンテナ外に公開する設定、
        "<ホスト側のポート番号>"=ホストマシーンが外部に公開する番号
        "<コンテナ側のポート番号>"=コンテナにマッピングするポート番号
        "-dを指定しないと"=フォアグラウンドでサーバが起動してログが流れてくる
        "-v"=ボリューム
        "-rm"=コンテナが終了した時点で自動的にコンテナの削除も行う
      
      
      # docker stop test-nginx
        test-nginxのコンテナを停止する
      
      
      # ホストマシン上のディレクトリをコンテナにマウントする
        ホスト上のhtmlファイルはnginxコンテナで公開できるようにする
      
      
      # docker run --name some-nginx -v /some/content:/usr/share/nginx/html:ro -d nginx
        nginxのコンテナを立ち上げるコマンド~バインドマウントを使用する~
        # $ docker run --name <コンテナ名> -d \\ 
        # -v <ホスト側のディレクトリ>:<コンテナ側のマウントポイント>:<オプション> \\
        # -p <ホスト側のポータ番号>:<コンテナ側のポート番号> \\
        # <イメージ名>
        "ro"=read_only
        # -v /Users/<ユーザー名>/docker-tutrial/html:/usr/share/nginx/html:ro
        macの場合の-vオプションの引数
      
      
      
      # $ docker cp <ホスト上のコピーしたいファイルのパス> \\
      #  <コンテナ名 or ID>:<コピー先のパス>
      ホストマシンのファイルをコンテナ内にコピーする場合
        
        
      
      # $ docker cp <コンテナ名 or ID>:<コンテナ上のコピーしたいファイルのパス> \\
      #  <コピー先のパス>
      コンテナ内のファイルをホストマシンにコピーする場合
      
      
      # $ docker create --name status-test -it alpine /bin/sh
      コンテナが作成されてスタートする前、コンテナの作成
      "alpine"=軽量なイメージ
      "-i"=コンテナの標準入力を取得して双方向に接続するもの
      "-t"=コンテナ内にttyを割り当てる
      "-it"コンテナでshellを実行してフォアグラウンドで実行状態にしたいときによく使われる
      
      
      # docker ps
      現在実行中のコンテナを確認する
      "-a"=実行中じゃないコンテナも表示する
      
      # $ docker pause status-test
      status-testコンテナを一時中断する
      
      
      # $ docker unpause status-test
      pauseしてるstatus-testコンテナをrunningにする
      
      
      # $ docker stop status-test
      status-testのコンテナが終了した状態にする(exit)
      
      
      # $ docker start staus-test
      staus-testのコンテナを起動する
      
      
      # $ docker attach <コンテナ名 or コンテナID>
      コンテナのシェルに接続するコマンド
      exitする時にコンテナは終了する
      
      
      # $ docker exec -it <コンテナ名 or コンテナID> /bin/bash
      コンテナのシェルに接続するコマンド　
      exitをする時コンテナは起動させたまま
      
      
      # $ docker commit <コンテナ名 or コンテナID> <イメージ名>:<タグ名>
      コンテナの状態をイメージして保存することができる
      何か操作したコンテナからイメージを作成した場合コンテナ内で行われた作業は
      どこにも明確な記録として残らなくなる
      docker historyで記録に残らない
      
      
      # $ docker run --link <コンテナ名 or コンテナID>:<リンク先コンテナの別名>
      コンテナ名、または別名(エイリアスでリンク先に通信できるようになる)
      
      
      # docker search [オプション　] 検索キーワード
        Docker Hubに公開されているイメージを検索する
        --automated : Automated Buildのみ表示
        --no-trunc : 結果をすべて表示する
        -s : お気に入りの数の指定
    '''
  }
]
tags: [
  "docker"
  "run"
  "images"
  "tag"
  "inspect"
  "rmi"
  "pull"
  "search"
]
isStarred: false
isTrashed: false
