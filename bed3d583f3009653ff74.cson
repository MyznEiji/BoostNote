type: "SNIPPET_NOTE"
folder: "c7de755d4eba19dc5c05"
title: "GItGeneral"
description: "GItGeneral"
snippets: [
  {
    name: "GitGeneral.cs"
    mode: "C#"
    content: '''
      //癖
      ファイルを変更したら、git statusで何を変更したのかを確認してから
      git add　や git commitを行なっていく
      
      //HEAD~　(チルダ)
      ~世代前のコミットを指定できる。
      一番上の親を指定する。HEADを基点にして数値文の親コミットまで指定する
      
      //HEAD^ (キャレット)
      複数ある親コミットのなかから指定できる。
      
      //gitの設定ファイルはどこに保存されているのか
      --globalをつけるとPC全体の設定になる
      ~/ .gitconfig
      ~/ .config /git /config
      
      何もつけないとそのプロジェクトのディレクトリに保存される
      project/.git/config
      
      //タグには２種類ある
      1注釈付き(annotated)　正式なタグ情報がしっかりしている
        名前に加えてコメント、署名を付けられる。
      2軽量(lightWeight)　情報量を減らした省略系のタグ
        名前だけを付けられる
      
      //マージの３種類
      1Fast Foward ブランチが枝分かれしてなかった時はブランチのポインタを前に進めるだけ
      2Auto Merge 枝分かれして開発していた場合、、マージコミットという新しいコミットを作る
      3コンフリクト 同じファイルに同じ行に対して異なる編集を行った時
      
      //コンフリクトの解決の仕方
      "コンフリクトしたファイル"
      <h1>Gitチュートリアル<h1>
      <p>ようこそ</p>
      <<<<<<<HEAD
      <p>git addについて学ぼう</p>
      =======
      <p>git commitを知ろう</p>
      >>>>>>>feature
      
      <<<<<<<HEAD ~ ======== : HEADの変更部分
      ======= ~ >>>>>>>feature : featureの変更部分
      
      
      "コンフリクトを解決したファイル"
      <h1>Gitチュートリアル</h1>
      <p>ようこそ</p>
      <p>git addについて学ぼう</p>
      <p>git commitを知ろう</p>
      
      1ファイルの内容を書き換える
      2[<<],[==][>>]の記述を削除
      
      
      //コンフリクト関連の事故が起きにくい運用
      ・複数人で同じファイルを変更しない
      ・pullやmergeする前に変更中の状態をなくしておく(commitやstashをしておく)
      ・pullするときはpullするブランチに移動してからpullする
      
      //プルリクエスト
      自分の変更したコードをリポジトリに取り込んでもらえるように依頼する機能
      手順
      1 masterブランチを最新に更新
      2 ブランチを作成
      3 ファイルを変更
      4 変更をコミット
      5 GitHubへプッシュ
      6 プルリクエストを送る
      7 コードレビュー
      8 プルリクエストをマージ
      9 ブランチを削除
      
      
      
      //GitHubFlowを実践する上でのポイント
      1 masterブランチは常にデプロイできる状態を保つ
      2 新開発はmasterブランチから新しいブランチを作成してスタート
      3 作成した新しいブランチ上で作業しコミットする
      4 定期的にpush
      5 masterにマージするためにプルリクエストを使う
      6 必ずレビューを受ける
      7 masterブランチにマージしたらすぐデプロイする←テストとデブロイ作業は自動化
      
      
      //リベース
      変更を統合する時に履歴を綺麗に整えるために使う
      
      
      //タグ
      コミットを参照しやすくするためにわかりやすい名前をつけるのがタグ
      よくリリースポイントに使う
      
      //リベースでしてはいけないこと
      GitHubにプッシュしたコミットをリベースするのはNG
      
      
      //マージとリベースのメリットデメリット
      1マージ
        +コンフリクトの解決が比較的簡単
        -マージコミットがたくさんあると履歴が複雑化する
        
        作業の履歴を残したいならマージを使おう
        プッシュした後の変更はまマージを使う
      
      2リベース
        +履歴を綺麗に保つことができる
        -コンフリクトの解決が若干面倒
        
        履歴を綺麗にしたいならリベースを使おう
        プッシュしていないローカルの変更にはリベースを使い、
      
      //マージコミットファイル
      通常のコミットは親ファイルを１つしか持っていないが、 マージコミットファイルは親ファイルを
      masterとマージ元のファイルを持っている。
      
      
      //Gitはスナップショットを記録している。
      バージョンごとで変更ファイルは差分ではなく、丸々スナップショットで記録している。
      スナップショットで開発することで複数人での開発のスピードを上げる。
      ブランチ、マージを差分をいちいち計算しなくていいから、スピーディー。
      コミットを戻るときも、差分を計算しないでスナップショットで戻るため楽
      
      
      //GitFlow
      ローカルでスナップショットを記録(ワークツリーをローカルリポジドリにスナップショットを追加)　
      →GitHubへアップ
      
      //コミット
      スナップショットを記録すること
      
      //ローカルは３つのエリアに分かれている
      1ワークツリー
      2ステージ
      3リポジトリ
      
      //ローカルの流れ
      ワークツリーで変更したファイル→ステージに追加する→リポジトリにスナップショットに追加する
      
      
      //ワークツリー
      ファイルを変更したりする自分の作業
      
      //ステージ
      ワークツリーをリポジトリに保存する前に変更を追加する場所
      コミットする変更を準備する場所
      スナップショットの準備する場所
      手元で変更したファイルが完了したものもあれば、してないものもある
      ステージには変更完了したファイルしか追加されない。
      
      //リポジトリ　
      履歴データの保管場所
      
      
      //Gitのデータの管理の仕方について補足
      //Gitオブジェクト
      
      git add や git commit した時、「圧縮ファイル」「ツリーファイル」「コミットファイル」が
      作成される。
      Gitではこれらのファイルを「Gitオブジェクト」と呼んでいます。
      Gitオブジェクトは「.git/objects」ディレクトリの下に保存されます。
      
      
      //圧縮ファイル
      圧縮ファイルはファイルの中身そのものを圧縮したもの。正確には
      「blob（ブロブ）オブジェクト」と言います。blobというのは「カタマリ」という意味です。
      ファイルの中身を圧縮しただけのカタマリということになります。
      圧縮ファイルのファイル名はハッシュIDになります。
      ハッシュIDというのは、ヘッダー（ファイル内容の文字数など、ファイルのメタ情報）とファイル内容を、
      SHA-1というハッシュ関数で40文字の英数字に変換したものです。
      ハッシュIDのうち、先頭2文字をディレクトリ名に、残り38文字をファイル名にして保存します。
      
      ```
      # 新しいディレクトリを作成します
      $ mkdir sample
       
      # そのディレクトリに移動します
      $ cd sample
       
      # Gitを初期化します。ここまでは前準備です
      $ git init
       
      # ファイルの中身が「Hello, world!」というgreetingというファイルを作成します
      $ echo 'Hello, world!' > greeting
       
      # greetingのハッシュIDを表示します
      $ git hash-object greeting
      af5626b4a114abcb82d63db7c8082c3c4756e51b
      ```
      
      このようにハッシュIDは、「af5626b4a114abcb82d63db7c8082c3c4756e51b」
      という40文字の英数字になります。
      
      
      //git add して圧縮ファイルを作成
      
      ```
      # git add することで圧縮ファイルを作成します
      $ git add greeting
       
      # .git以下のファイル構造を表示します。以下は今回関係している部分だけを抜粋
      $ tree .git
      .git
      ├─ objects
         ├─ af
            └─ 5626b4a114abcb82d63db7c8082c3c4756e51b
      ```
      圧縮ファイルは「.git/objects/af/5626b4a114abcb82d63db7c8082c3c4756e51b」
      として保存されています。
      
      ここで重要なことは、ハッシュIDというのは、ファイルの中身に対して一意になるということです。
      中身が同じファイルであれば必ず同じハッシュIDになります。そのため、
      ファイルの中身が同じであれば git add しても追加で圧縮ファイルが作られることはありませんし、
      ファイルの中身に変更があれば git add すると別の圧縮ファイルが作成されます。
      
      
      
      
      //ツリーファイル
      
      圧縮ファイルは、ファイルの中身を圧縮したものを保存していて、圧縮ファイルのファイル名もファイルの中身をベースにハッシュ関数で作成されたものでした。つまり、圧縮ファイルにはもともとのファイル名の情報がどこにも残っていないことになります。
      
      そこで、ファイル名とファイルの中身の組み合わせ（ファイル構造）を保存するためにあるのがツリーファイルでしたね。コミットをするとツリーファイルが作成されます。ツリーファイルは「treeオブジェクト」と言います。
      
      ツリーファイルは動画で説明したことと実際のファイル構造に違いがあるため注意してください。
      動画ではファイル名と圧縮ファイル名の組み合わせを保存したものとして説明しました。実際は、ディレクトリの一つの階層ごとに一つのツリーファイルになっていて、ツリーファイルには圧縮ファイルだけでなくツリーファイルも保存されています。
      
      言葉ではわかりにくいので、具体的に見てみましょう。
      
      # コミットしてツリーファイルを作成します
      # -m オプションを付けることでエディタを立ち上げずにコミットできます
      $ git commit -m 'add greeting'
      [master (root-commit) ae682f6] add greeting
       1 file changed, 1 insertion(+)
       create mode 100644 greeting
       
      # master ブランチ上での最後のコミットが指しているツリーファイルの中身を表示します
      $ git cat-file -p master^{tree}
      100644 blob af5626b4a114abcb82d63db7c8082c3c4756e51b    greeting
      最後のコミットが指しているtreeには、blobオブジェクト「af5626b4a114abcb82d63db7c8082c3c4756e51b」が greeting というファイル名だ、ということが保存されています。ここまでは動画の通りです。
      
      ではここで、ディレクトリを追加してコミットすると何が起こるでしょうか。
      
      $ mkdir subdir
       
      # subdir ディレクトリの下に goodmorning というファイルを作成します
      $ echo 'Goodmorning!' > subdir/goodmorning
       
      $ git add subdir
      $ git commit -m 'add subdir'
      [master 75458c8] add subdir
       1 file changed, 1 insertion(+)
       create mode 100644 subdir/goodmorning
       
      # ツリーファイルのIDを取得するために、最後のコミットの中身を表示します
      # git cat-file -p master^{tree} コマンドでも大丈夫です
      $ git cat-file -p HEAD
      tree acd75d1289b95787ecaab96c73fe1f3dbfa9cf67
      parent ae682f61f39b5c364781cb179035ae534c56a326
      author kiyodori <メールアドレス> 1493763216 +0900
      committer kiyodori <メールアドレス> 1493763216 +0900
       
      add subdir
       
      # ツリーファイルの先頭の文字を指定して、ツリーファイルの中身を表示します
      $ git cat-file -p acd75d
      100644 blob af5626b4a114abcb82d63db7c8082c3c4756e51b    greeting
      040000 tree 60ac1b2d01e7f0c21178dcc2e767fb9a24d97124    subdir
      blogオブジェクトに関してはさっきと同じです。そこに、treeオブジェクト「60ac1b2d01e7f0c21178dcc2e767fb9a24d97124」のツリー名は subdir だよ、というのが追加されています。
      
      ここが注目ポイントで、ツリーファイルの中にツリーファイルが含まれているんですね。このように、ツリーファイルは一つのディレクトリに対応していて、ツリーファイルの中にツリーファイルと圧縮ファイルが含まれるようになっています。
      
      
      図. ツリーファイルの構造
      
      一応 subdir のツリーファイルの中身も確認しておきましょう。
      
      # ツリーファイルの先頭の文字を指定して、ツリーファイルの中身を表示します
      $ git cat-file -p 60ac1b
      100644 blob fa476f276a6fa984a789416f63f925e999834081    goodmorning
      subdir ディレクトリには blobオブジェクト「fa476f276a6fa984a789416f63f925e999834081」がgoodmorning というファイル名で保存されています。
      
      ここまでを振り替えると、一つのファイルに一つの圧縮ファイルが対応していて（※）、一つのディレクトリに一つのツリーファイルが対応していることがわかります。ツリーファイルは構造や名前を持たない圧縮ファイルに構造を与えるためのもので、圧縮ファイルやツリーファイルを保存しているのです。
      
      ※ ファイルの中身が同じでファイル名が違う場合、圧縮ファイルはファイルの中身をベースに作成されるため、圧縮ファイルは同じものになります。
      
      コミットファイル
      
      ツリーファイルが作成されたことで、ファイルの構造がわかるようになりました。しかしまだ、いつ、誰が、何を、何のために変更したのかということがわかりません。
      
      そこで、その情報を保存するためにあるのがコミットファイルでした。コミットファイルは正確には「commitオブジェクト」と言います。
      
      早速コミットファイルの中身を確認してみましょう。
      
      # 最新のコミットファイルの中身を表示します
      $ git cat-file -p HEAD
      tree acd75d1289b95787ecaab96c73fe1f3dbfa9cf67
      parent ae682f61f39b5c364781cb179035ae534c56a326
      author kiyodori <メールアドレス> 1493763216 +0900
      committer kiyodori <メールアドレス> 1493763216 +0900
       
      add subdir
      まず、コミットした時点のtree「acd75d1289b95787ecaab96c73fe1f3dbfa9cf67」が保存されています。これはこのプロジェクトの一番上のディレクトリのツリーファイルになります。一番上の階層のツリーをコミットファイルに保存することで、コミットした時点でのスナップショットを記録しています。
      
      次がparent、親コミットを保存しています。親コミットは「ae682f61f39b5c364781cb179035ae534c56a326」です。Gitはこのように親コミットを保存することでコミットの履歴を辿れるようにしているんでしたね。
      
      あとは作成者の名前とメールアドレス、改行、コミットメッセージと続きます。これで、変更者と変更理由がわかります。
      
      まとめ
      
      Gitは変更履歴を保存する時、圧縮ファイル、ツリーファイル、コミットファイルという形でスナップショットを記録しています。
      Gitの実体は基本的にはこれだけです。とてもシンプルですね。
      
      Gitのコマンドは、この3つのGitオブジェクトに対して何らかの操作をしているだけです。
      これから色々なコマンドを学んでいきます。その時、コマンドを闇雲に覚えるのではなく、このデータ構造に対してどういう操作をしているコマンドなのかということをイメージしてもらえれば、Gitが実際どのようなことをしているかがわかると思います。
      
      それでは次回から、Gitの具体的なコマンド、操作に進んでいきましょう。
      
      
      //バージョン管理したくないファイルとは
      1パスワードなどの機密フォルダ。GitHubに上げて公開すると流出することになる。
      2チームの開発で必要にないファイル(自動生成されるファイルやキャッシュなど)
        
      
    '''
  }
]
tags: []
isStarred: false
isTrashed: false
createdAt: "2017-08-27T03:51:43.981Z"
updatedAt: "2017-09-08T02:09:24.545Z"
