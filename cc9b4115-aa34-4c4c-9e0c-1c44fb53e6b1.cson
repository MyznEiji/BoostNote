createdAt: "2018-03-13T13:50:49.725Z"
updatedAt: "2018-03-22T07:23:04.779Z"
type: "SNIPPET_NOTE"
folder: "5202b1c383243659e92c"
title: "LaravelModel"
description: "LaravelModel"
snippets: [
  {
    name: "LaravelModel.py"
    mode: "Python"
    content: '''
      # モデルの命名規則
      Laravelでは、ファイルやテーブルなどの命名を規則に従った形にする必要があります。
      モデルとテーブルに関する命名規則は以下のようになっており、これに従えばテーブルと
      モデルが結びつきます。
      
      種類	                概要	               名前例
      モデルクラス名	         先頭は大文字、単数形	   Tweet
      モデルクラスのファイル名	先頭は大文字、単数形	  Tweet.php
      テーブル名	             先頭は小文字、複数形	   tweets
      
      
      # orderByメソッド
      orderByメソッドは、テーブルから取得してきたプロパティたちを並び替えるメソッドです。
      例えば「contents」という名のテーブルがあり、以下のようにContentクラスからallメソッドを
      利用して全てのレコードを取得してきたとします。この時、orderByメソッドを利用して
      取得してきたレコードを並び変えることができます。
      ASC(昇順)
      DESC(降順)
      
      $tweets = Tweet::orderBy('created_at', 'DESC')->get();
          
      並び替え後にデータを取得するためにorderByメソッドの後にgetメソッドを使います。
          
      
      # whereメソッド
      whereメソッドはeloquentメソッドのうちの一つです。モデル::where(条件)とすることで、
      テーブルの中から条件によって絞り込みを行うことができます。
      getメソッドと組み合わせることで、条件に一致したレコードだけを保存できます。
      
      また、whereメソッドを連続して記述することによって、複数の条件に一致したレコードを
      取得することもできます。
      
        
        
        
      
      
      # allメソッド
      allメソッドはModelを継承したモデルと結びつくテーブルのレコードを全て取得します。
        >>> App\\Tweet::all();
      
            
            
      # new演算子・saveメソッド
      new演算子はクラスのインスタンスを生成するメソッドです。
      Modelを継承しているモデルクラスの場合、new演算子を実行すると関連するテーブルのカラム名が
      キーになった連想配列のようなものが生成されます。これをモデルクラスのインスタンスと呼びます。
      インスタンスのそれぞれのキーに値を代入してsaveメソッドを実行するとテーブルに保存されます。
      
      >>> $tweet = new App\\Tweet(array('name' => 'takashi', 'text' => 'Nice to meet you!'));
      => App\\Tweet {#670
           name: "takashi",
           text: "Nice to meet you!",
         }
      >>> $tweet->save();
      => true
      
      
      # createメソッド
      createメソッドはレコードの作成を行なうことの出来るメソッドです。
      new演算子とsaveメソッドを使用して行なった処理をcreateメソッドで一気に行なうことが
      できるので、単にレコードを作成する場合にはこのメソッドを使用しましょう。
      >>> App\\Tweet::create(array('name' => 'takashi', 'text' => 'Nice to meet you!'));
      => App\\Tweet {#633
           name: "takashi",
           text: "Nice to meet you!",
           updated_at: "2016-10-27 16:33:57",
           created_at: "2016-10-27 16:33:57",
           id: 7,
         }
      
      
      # findメソッド
      findメソッドは引数に指定したidにあたる作品情報を1件だけ取得します。
      >>> $tweet = App\\Tweet::find(1);
      => App\\Tweet {#636
           id: 1,
           name: "ken",
           text: "こんにちは！",
           image: "",
           created_at: null,
           updated_at: null,
         }
      
      
      # アソシエーション
      アソシエーションとはモデル間の関連付けを管理する機能のことで、
      定義しておくことでモデルをまたいだデータの呼び出しをより簡単に行なうことが
      できるようになります。
        
        
      Userモデルの視点で考えると、あるuserの作成したtweetが複数個ある状態と言えます。
      この状態のことをhas manyの関係といい、今回の場合には「User hasMany Tweets」の
      状態であると言えます。
      
      
      Tweetモデルの視点で考えると、全てのtweetはいずれかのuserに属している状態と言えます。
      この状態のことをbelongsToの関係といい、今回の場合は「Tweet belongsTo User」の
      状態であると言えます。
      
      # n+1問題
      モデルを利用してデータベースの情報にアクセスする際にはSQLが発行されます。
      SQLが発行されるたびにデータベースに対して通信が走るので、SQLが大量に発行されれば処理が
      重くなります。n+1問題とは、データを呼び出す際に大量のSQLが発行されてしまう
      問題のことです。
      
      今回の場合、indexアクションで全ツイートを取得する1回に加えて、
      アソシエーションを利用してツイートの数だけユーザー情報を呼び出しています。つまり、
      現在の状態だとツイート数＋1回SQLが発行されています。この状態のことをn+1問題と言います。
      
      
      # withメソッド
      withメソッドはn+1問題を解消することができます。指定された関連モデルをまとめて
      取得することで、SQLの発行回数を減らすことができます。書き方は、
      モデル名::with(関連するモデル名)とします。引数で、関連モデルを指定します。
      
      今回、usersテーブルとtweetsテーブルの間には以下の図のような関係があります。
      tweetsテーブルのレコードは必ず1つのusersテーブルのレコードに属しているので、
      withメソッドを利用することでtweetsテーブルのレコードを取得する段階で関連する
      usersテーブルのレコードも一度に取得することができます。
      
      
      
      # takeメソッド
      takeメソッド はデータをいくつ取得するかというのが指定できるメソッドで、
      引数には取得したい件数を指定します。
      
      モデル名::take(取得件数);
          
          
          
      # LIKE句
      LIKE句は、あいまいな文字列の検索をすることができるもので、whereメソッドと一緒に使います。
      
      あいまいな文字列の検索とはどういうことか。
      例えば、1文字目に'a'という文字列が入ったデータや最後の文字に'b'が入っているデータ、
      文字列の途中に'c'が入ったデータなどを検索したい時に、あいまい文字列というものを使って
      検索することです。
      
      
      あいまい文 字列について
      
      文字列 	意味
      %	      任意の文字列(空白文字列含む)
      _	      任意の1文字
      
      
      実行サンプル
      
      実行例	                        詳細
      where('title', LIKE', "a%")	  aから始まるタイトル
      where('title', LIKE', "%b")	  bで終わるタイトル
      where('title', LIKE', "%c%")	cが含まれるタイトル
      where('title', LIKE', "d_")	  dで始まる2文字のタイトル
      where('title', LIKE', "_e")	  eで終わる2文字のタイトル
      
            
            
      # avgメソッド
      avgメソッドは、avgメソッドを利用するインスタンス取得先のテーブルのカラムを
      引数にとります。その値の平均を、小数点ありの状態で返してくれます。
      例えば、生徒の得点を記録するscoreカラムを持ったstudentsテーブルと関連する
      Studentクラスがあったとします。scoreカラムの平均を求めるには、以下のようにします。
      
            
            
      # round()関数
      round()関数はPHPに標準定義されている関数で、小数点ありの数字が利用できます。
      利用した数字の小数点以下を四捨五入します。
            
            
      # DB::rawメソッド
      DB::rawメソッドはSQLプログラムを直接記述したい場合に使います。DB::rawメソッドの
      引数にSQLプログラムを書くことでSQLを実行することができます。今回の場合、
      count関数やas句などがSQLの文法に当たります。また、use DB;としてDBクラスを
      インクルードする必要があります。
      
            
            
      # mapメソッド
      mapメソッドはCollectionクラスのインスタンスに対して利用できるメソッドです。
      EloquentORMのメソッドを使ってデータベースから値を取得した場合、
      それらは全てCollectionクラスのインスタンスとなります。mapメソッドは
      Collectionインスタンスの中身を1つずつ取り出して処理を行います。
      そして中身を並べ替えた新しいインスタンスを生成します。
    '''
  }
]
tags: []
isStarred: false
isTrashed: false
